import { applyMiddleware, compose, legacy_createStore } from 'redux';
import * as React$1 from 'react';
import React__default, { useMemo, useContext, useRef, useEffect as useEffect$1, createContext } from 'react';
import { createSelector } from 'reselect';

function isLogicWrapper(logic) {
  return '_isKea' in logic;
}
function isBuiltLogic(logic) {
  return '_isKeaBuild' in logic;
}
var shallowCompare = function shallowCompare(obj1, obj2) {
  var keys1 = Object.keys(obj1);
  var keys2 = Object.keys(obj2);
  return keys1.length === keys2.length && keys1.every(function (key) {
    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];
  });
};

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}
function _createForOfIteratorHelperLoose(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (t) return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
    t && (r = t);
    var o = 0;
    return function () {
      return o >= r.length ? {
        done: !0
      } : {
        done: !1,
        value: r[o++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function _regenerator() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
  var e,
    t,
    r = "function" == typeof Symbol ? Symbol : {},
    n = r.iterator || "@@iterator",
    o = r.toStringTag || "@@toStringTag";
  function i(r, n, o, i) {
    var c = n && n.prototype instanceof Generator ? n : Generator,
      u = Object.create(c.prototype);
    return _regeneratorDefine(u, "_invoke", function (r, n, o) {
      var i,
        c,
        u,
        f = 0,
        p = o || [],
        y = !1,
        G = {
          p: 0,
          n: 0,
          v: e,
          a: d,
          f: d.bind(e, 4),
          d: function (t, r) {
            return i = t, c = 0, u = e, G.n = r, a;
          }
        };
      function d(r, n) {
        for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {
          var o,
            i = p[t],
            d = G.p,
            l = i[2];
          r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));
        }
        if (o || r > 1) return a;
        throw y = !0, n;
      }
      return function (o, p, l) {
        if (f > 1) throw TypeError("Generator is already running");
        for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {
          i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);
          try {
            if (f = 2, i) {
              if (c || (o = "next"), t = i[o]) {
                if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object");
                if (!t.done) return t;
                u = t.value, c < 2 && (c = 0);
              } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1);
              i = e;
            } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;
          } catch (t) {
            i = e, c = 1, u = t;
          } finally {
            f = 1;
          }
        }
        return {
          value: t,
          done: y
        };
      };
    }(r, o, i), !0), u;
  }
  var a = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  t = Object.getPrototypeOf;
  var c = [][n] ? t(t([][n]())) : (_regeneratorDefine(t = {}, n, function () {
      return this;
    }), t),
    u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
  function f(e) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e;
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine(u), _regeneratorDefine(u, o, "Generator"), _regeneratorDefine(u, n, function () {
    return this;
  }), _regeneratorDefine(u, "toString", function () {
    return "[object Generator]";
  }), (_regenerator = function () {
    return {
      w: i,
      m: f
    };
  })();
}
function _regeneratorDefine(e, r, n, t) {
  var i = Object.defineProperty;
  try {
    i({}, "", {});
  } catch (e) {
    i = 0;
  }
  _regeneratorDefine = function (e, r, n, t) {
    function o(r, n) {
      _regeneratorDefine(e, r, function (e) {
        return this._invoke(r, n, e);
      });
    }
    r ? i ? i(e, r, {
      value: n,
      enumerable: !t,
      configurable: !t,
      writable: !t
    }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2));
  }, _regeneratorDefine(e, r, n, t);
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

var reservedKeys = {
  key: true,
  path: true,
  pathString: true,
  props: true,
  inputs: true,
  wrapper: true,
  wrap: true,
  build: true,
  mount: true,
  unmount: true,
  isMounted: true,
  findMounted: true,
  findAllMounted: true,
  extend: true
};
function activatePlugin(pluginToActivate) {
  var plugin = typeof pluginToActivate === 'function' ? pluginToActivate() : pluginToActivate;
  var _getContext = getContext(),
    plugins = _getContext.plugins;
  if (!plugin.name) {
    throw new Error('[KEA] Tried to activate a plugin without a name!');
  }
  if (plugins.activated.find(function (p) {
    return p.name === plugin.name;
  })) {
    throw new Error("[KEA] Tried to activate plugin \"" + plugin.name + "\", but it was already installed!");
  }
  plugins.activated.push(plugin);
  if (plugin.defaults) {
    var fields = Object.keys(typeof plugin.defaults === 'function' ? plugin.defaults() : plugin.defaults);
    for (var _i = 0, _fields = fields; _i < _fields.length; _i++) {
      var key = _fields[_i];
      if (plugins.logicFields[key] || reservedKeys[key]) {
        console.error("[KEA] Plugin \"" + plugin.name + "\" redefines logic field \"" + key + "\". Previously defined by " + (plugins.logicFields[key] || 'core'));
      }
      plugins.logicFields[key] = plugin.name;
    }
  }
  if (plugin.events) {
    for (var _i2 = 0, _Object$keys = Object.keys(plugin.events); _i2 < _Object$keys.length; _i2++) {
      var _key = _Object$keys[_i2];
      if (!plugins.events[_key]) {
        plugins.events[_key] = [];
      }
      plugins.events[_key].push(plugin.events[_key]);
    }
    plugin.events.afterPlugin && plugin.events.afterPlugin();
  }
}
function runPlugins(key) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  var _getContext2 = getContext(),
    plugins = _getContext2.plugins,
    debug = _getContext2.options.debug;
  if (debug) {
    var _console;
    (_console = console).log.apply(_console, ["[KEA] Event: " + key].concat(args));
  }
  if (plugins && plugins.events[key]) {
    plugins.events[key].forEach(function (pluginFunction) {
      pluginFunction.apply(void 0, args);
    });
  }
}

var ATTACH_REDUCER$1 = '@KEA/ATTACH_REDUCER';
var DETACH_REDUCER$1 = '@KEA/DETACH_REDUCER';
var defaultState = {};
function initRootReducerTree(pathStart) {
  var _getContext = getContext(),
    _getContext$reducers = _getContext.reducers,
    tree = _getContext$reducers.tree,
    whitelist = _getContext$reducers.whitelist;
  if (!tree[pathStart]) {
    if (whitelist && !whitelist[pathStart]) {
      throw new Error("[KEA] Can not start reducer's path with \"" + pathStart + "\"! Please add it to the whitelist");
    }
    tree[pathStart] = {};
    regenerateRootReducer(pathStart);
  }
}
function keaReducer(pathStart) {
  if (pathStart === void 0) {
    pathStart = 'scenes';
  }
  var _getContext2 = getContext(),
    roots = _getContext2.reducers.roots;
  initRootReducerTree(pathStart);
  return function (state, action, fullState) {
    if (state === void 0) {
      state = defaultState;
    }
    return roots[pathStart] ? roots[pathStart](state, action, fullState) : state;
  };
}
function attachReducer(logic) {
  var path = logic.path,
    reducer = logic.reducer;
  var _getContext3 = getContext(),
    tree = _getContext3.reducers.tree,
    attachStrategy = _getContext3.options.attachStrategy,
    store = _getContext3.store;
  var pathStart = path[0].toString();
  initRootReducerTree(pathStart);
  var pointer = tree;
  for (var i = 0; i < path.length; i++) {
    var pathPart = path[i].toString();
    if (i === path.length - 1) {
      if (pointer[pathPart]) {
        if (i === 0 && typeof pointer[pathPart] === 'object' && Object.keys(pointer[pathPart]).length === 0) ; else if (typeof pointer[pathPart] !== 'function') {
          console.error("[KEA] Can not add reducer to \"" + path.join('.') + "\". There is something in the way:", pointer[pathPart]);
          return;
        }
      }
      pointer[pathPart] = reducer;
    } else {
      if (!pointer[pathPart]) {
        pointer[pathPart] = {};
      }
      pointer = pointer[pathPart];
    }
  }
  regenerateRootReducer(pathStart);
  if (attachStrategy === 'dispatch' || attachStrategy === 'replace') {
    runPlugins('beforeAttach', logic);
    if (attachStrategy === 'dispatch') {
      store && store.dispatch({
        type: ATTACH_REDUCER$1,
        payload: {
          path: path,
          reducer: reducer
        }
      });
    } else if (attachStrategy === 'replace') {
      store && store.replaceReducer(createReduxStoreReducer());
    }
    runPlugins('afterAttach', logic);
  }
}
function detachReducer(logic) {
  var path = logic.path;
  var _getContext4 = getContext(),
    tree = _getContext4.reducers.tree,
    detachStrategy = _getContext4.options.detachStrategy,
    store = _getContext4.store;
  var pathStart = path[0].toString();
  if (detachStrategy === 'persist') {
    return;
  }
  var detached = false;
  for (var i = path.length - 2; i >= 0; i--) {
    var pointerToHere = tree;
    for (var j = 0; j <= i; j++) {
      pointerToHere = pointerToHere && pointerToHere[path[j].toString()] || undefined;
    }
    if (pointerToHere) {
      if (Object.keys(pointerToHere).length === 0) ; else if (Object.keys(pointerToHere).length >= 1 && i === path.length - 2 && typeof pointerToHere[path[i + 1].toString()] === 'function') {
        delete pointerToHere[path[i + 1].toString()];
        detached = true;
      } else if (detached && Object.keys(pointerToHere).length >= 1 && i < path.length - 2 && Object.keys(pointerToHere[path[i + 1].toString()]).length === 0) {
        delete pointerToHere[path[i + 1].toString()];
      } else {
        break;
      }
    }
  }
  regenerateRootReducer(pathStart);
  if (detached) {
    if (detachStrategy === 'dispatch' || detachStrategy === 'replace') {
      runPlugins('beforeDetach', logic);
      if (detachStrategy === 'dispatch') {
        store && store.dispatch({
          type: DETACH_REDUCER$1,
          payload: {
            path: path
          }
        });
      } else if (detachStrategy === 'replace') {
        store && store.replaceReducer(createReduxStoreReducer());
      }
      runPlugins('afterDetach', logic);
    }
  }
}
function regenerateRootReducer(pathStart) {
  var _getContext5 = getContext(),
    _getContext5$reducers = _getContext5.reducers,
    tree = _getContext5$reducers.tree,
    roots = _getContext5$reducers.roots,
    whitelist = _getContext5$reducers.whitelist;
  if (pathStart !== 'kea' && !whitelist && typeof tree[pathStart] === 'object' && Object.keys(tree[pathStart]).length === 0) {
    delete roots[pathStart];
  } else {
    roots[pathStart] = recursiveCreateReducer(tree[pathStart]);
  }
  regenerateCombinedReducer();
}
function recursiveCreateReducer(treeNode) {
  if (typeof treeNode === 'function') {
    return treeNode;
  }
  var children = {};
  Object.keys(treeNode).forEach(function (key) {
    if (typeof treeNode[key] !== 'undefined') {
      children[key] = recursiveCreateReducer(treeNode[key]);
    }
  });
  if (Object.keys(children).length > 0) {
    return combineKeaReducers(children);
  } else {
    var emptyObj = {};
    return function () {
      return emptyObj;
    };
  }
}
function combineKeaReducers(reducers) {
  return function combination(state, action, fullState) {
    if (state === void 0) {
      state = {};
    }
    var reducerKeys = Object.keys(reducers);
    var stateChanged = Object.keys(state).length !== reducerKeys.length;
    var nextState = {};
    for (var _i = 0, _reducerKeys = reducerKeys; _i < _reducerKeys.length; _i++) {
      var key = _reducerKeys[_i];
      var reducer = reducers[key];
      var previousKeyState = state[key];
      var nextKeyState = reducer(previousKeyState, action, fullState || state);
      if (typeof nextKeyState === 'undefined') {
        throw new Error("[KEA] Reducer \"" + key + "\" returned undefined for action \"" + (action && action.type) + "\"");
      }
      nextState[key] = nextKeyState;
      stateChanged = stateChanged || nextKeyState !== previousKeyState;
    }
    return stateChanged ? nextState : state;
  };
}
function regenerateCombinedReducer() {
  var _getContext$reducers2 = getContext().reducers,
    redux = _getContext$reducers2.redux,
    roots = _getContext$reducers2.roots;
  var reducers = _extends({}, redux, roots);
  getContext().reducers.combined = combineKeaReducers(reducers);
}
function createReduxStoreReducer() {
  regenerateCombinedReducer();
  return function (state, action) {
    var _getContext$reducers$, _getContext$reducers3;
    if (state === void 0) {
      state = defaultState;
    }
    return (_getContext$reducers$ = (_getContext$reducers3 = getContext().reducers).combined) === null || _getContext$reducers$ === void 0 ? void 0 : _getContext$reducers$.call(_getContext$reducers3, state, action, state);
  };
}

var shim$1 = {exports: {}};

var useSyncExternalStoreShim_production = {};

var React = React__default;
function is(x, y) {
    return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
}
var objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue;
function useSyncExternalStore$2(subscribe, getSnapshot) {
    var value = getSnapshot(), _useState = useState({ inst: { value: value, getSnapshot: getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
    useLayoutEffect(function () {
        inst.value = value;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
    }, [subscribe, value, getSnapshot]);
    useEffect(function () {
        checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
        return subscribe(function () {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
        });
    }, [subscribe]);
    useDebugValue(value);
    return value;
}
function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
    }
    catch (error) {
        return !0;
    }
}
function useSyncExternalStore$1(subscribe, getSnapshot) {
    return getSnapshot();
}
var shim = "undefined" === typeof window ||
    "undefined" === typeof window.document ||
    "undefined" === typeof window.document.createElement
    ? useSyncExternalStore$1
    : useSyncExternalStore$2;
useSyncExternalStoreShim_production.useSyncExternalStore =
    void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;

var useSyncExternalStoreShim_development = {};

"production" !== process.env.NODE_ENV &&
    (function () {
        function is(x, y) {
            return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
        }
        function useSyncExternalStore$2(subscribe, getSnapshot) {
            didWarnOld18Alpha ||
                void 0 === React.startTransition ||
                ((didWarnOld18Alpha = !0),
                    console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
            var value = getSnapshot();
            if (!didWarnUncachedGetSnapshot) {
                var cachedValue = getSnapshot();
                objectIs(value, cachedValue) ||
                    (console.error("The result of getSnapshot should be cached to avoid an infinite loop"),
                        (didWarnUncachedGetSnapshot = !0));
            }
            cachedValue = useState({
                inst: { value: value, getSnapshot: getSnapshot }
            });
            var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
            useLayoutEffect(function () {
                inst.value = value;
                inst.getSnapshot = getSnapshot;
                checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
            }, [subscribe, value, getSnapshot]);
            useEffect(function () {
                checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
                return subscribe(function () {
                    checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
                });
            }, [subscribe]);
            useDebugValue(value);
            return value;
        }
        function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            inst = inst.value;
            try {
                var nextValue = latestGetSnapshot();
                return !objectIs(inst, nextValue);
            }
            catch (error) {
                return !0;
            }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot) {
            return getSnapshot();
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
            "function" ===
                typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React = React__default, objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1, shim = "undefined" === typeof window ||
            "undefined" === typeof window.document ||
            "undefined" === typeof window.document.createElement
            ? useSyncExternalStore$1
            : useSyncExternalStore$2;
        useSyncExternalStoreShim_development.useSyncExternalStore =
            void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
            "function" ===
                typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();

if (process.env.NODE_ENV === 'production') {
    shim$1.exports = useSyncExternalStoreShim_production;
}
else {
    shim$1.exports = useSyncExternalStoreShim_development;
}

var pauseCounter = 0;
var isPaused = function isPaused() {
  return pauseCounter !== 0;
};
var getStoreState$1 = function getStoreState() {
  return getContext().store.getState();
};
function useSelector(selector) {
  return shim$1.exports.useSyncExternalStore(getContext().store.subscribe, function () {
    return selector(getStoreState$1());
  });
}
function useValues(logic) {
  var builtLogic = useMountedLogic(logic);
  return useMemo(function () {
    var response = {};
    var _loop = function _loop() {
      var key = _Object$keys[_i];
      Object.defineProperty(response, key, {
        get: function get() {
          return useSelector(builtLogic.selectors[key]);
        }
      });
    };
    for (var _i = 0, _Object$keys = Object.keys(builtLogic.selectors); _i < _Object$keys.length; _i++) {
      _loop();
    }
    return response;
  }, [builtLogic.pathString]);
}
function useAllValues(logic) {
  var builtLogic = useMountedLogic(logic);
  var response = {};
  for (var _i2 = 0, _Object$keys2 = Object.keys(builtLogic.selectors); _i2 < _Object$keys2.length; _i2++) {
    var key = _Object$keys2[_i2];
    response[key] = useSelector(builtLogic.selectors[key]);
  }
  return response;
}
function useActions(logic) {
  var builtLogic = useMountedLogic(logic);
  return builtLogic['actions'];
}
function useAsyncActions(logic) {
  var builtLogic = useMountedLogic(logic);
  return builtLogic['asyncActions'];
}
var blankContext = /*#__PURE__*/createContext(undefined);
function useMountedLogic(logic) {
  var builtLogicContext = isLogicWrapper(logic) ? getContext().react.contexts.get(logic) : null;
  var defaultBuiltLogic = useContext(builtLogicContext || blankContext);
  var builtLogic = isLogicWrapper(logic) ? defaultBuiltLogic || logic.build() : logic;
  var unmount = useRef(undefined);
  if (!unmount.current) {
    batchChanges(function () {
      unmount.current = builtLogic.mount();
    });
  }
  var pathString = useRef(builtLogic.pathString);
  if (pathString.current !== builtLogic.pathString) {
    batchChanges(function () {
      var _unmount$current;
      (_unmount$current = unmount.current) === null || _unmount$current === void 0 ? void 0 : _unmount$current.call(unmount);
      unmount.current = builtLogic.mount();
      pathString.current = builtLogic.pathString;
    });
  }
  useEffect$1(function useMountedLogicEffect() {
    if (!unmount.current) {
      batchChanges(function () {
        unmount.current = builtLogic.mount();
        pathString.current = builtLogic.pathString;
      });
    }
    return function useMountedLogicEffectCleanup() {
      batchChanges(function () {
        unmount.current && unmount.current();
        unmount.current = undefined;
      });
    };
  }, []);
  return builtLogic;
}
var timeout;
function batchChanges(callback) {
  var previousState = getStoreState$1();
  pauseCounter += 1;
  try {
    callback();
  } catch (e) {} finally {
    pauseCounter -= 1;
  }
  var newState = getStoreState$1();
  if (previousState !== newState) {
    timeout && clearTimeout(timeout);
    timeout = setTimeout(function () {
      return getContext().store.dispatch({
        type: '@KEA/FLUSH'
      });
    }, 0);
  }
}

var reduxDevToolsCompose = typeof window !== 'undefined' && window['__REDUX_DEVTOOLS_EXTENSION_COMPOSE__'] ? window['__REDUX_DEVTOOLS_EXTENSION_COMPOSE__'] : compose;
var createDefaultOptions = function createDefaultOptions() {
  return {
    paths: [],
    reducers: {},
    preloadedState: undefined,
    middleware: [],
    compose: reduxDevToolsCompose,
    enhancers: [],
    plugins: []
  };
};
function createStore(opts) {
  if (opts === void 0) {
    opts = {};
  }
  var context = getContext();
  if (!context) {
    console.error('[KEA] Can not create a store without a Kea context.');
    return;
  }
  if (context['__store']) {
    console.error('[KEA] Already attached to a store! Exiting. Please reset the kea context before creating a store.');
    return;
  }
  var options = _extends({}, createDefaultOptions(), opts);
  context.reducers.redux = _extends({}, options.reducers);
  runPlugins('beforeReduxStore', options);
  if (options.middleware.length > 0) {
    options.enhancers = [applyMiddleware.apply(void 0, options.middleware)].concat(options.enhancers);
  }
  var composeEnhancer = options.compose || compose;
  var finalCreateStore = composeEnhancer.apply(void 0, [pauseListenersEnhancer].concat(options.enhancers))(legacy_createStore);
  if (options.paths && options.paths.length > 0) {
    context.reducers.whitelist = {};
    options.paths.forEach(function (pathStart) {
      context.reducers.whitelist[pathStart] = true;
      initRootReducerTree(pathStart);
    });
  } else {
    initRootReducerTree('kea');
  }
  var store = finalCreateStore(createReduxStoreReducer(), _extends({}, options.preloadedState));
  context['__store'] = store;
  runPlugins('afterReduxStore', options, store);
  return store;
}
var pauseListenersEnhancer = function pauseListenersEnhancer(createStore) {
  return function (reducer, initialState) {
    var store = createStore(reducer, initialState);
    var storeSubscribe = store.subscribe;
    store.subscribe = function (observer) {
      var pausedObserver = function pausedObserver() {
        if (!isPaused()) {
          observer();
        }
      };
      return storeSubscribe(pausedObserver);
    };
    return store;
  };
};

var _excluded = ["plugins", "createStore", "defaults"];
var context;
function getContext() {
  return context;
}
var getStoreState = function getStoreState() {
  return getContext().store.getState();
};
function setContext(newContext) {
  context = newContext;
}
var contextId = 0;
function openContext(options, initial) {
  if (options === void 0) {
    options = {};
  }
  if (initial === void 0) {
    initial = false;
  }
  if (context) {
    console.error('[KEA] overwriting already opened context. This may lead to errors.');
  }
  var _options = options,
    plugins = _options.plugins,
    _options$createStore = _options.createStore,
    createStoreOptions = _options$createStore === void 0 ? true : _options$createStore,
    defaults = _options.defaults,
    otherOptions = _objectWithoutPropertiesLoose(_options, _excluded);
  var newContext = {
    contextId: "kea-context-" + contextId++,
    plugins: {
      activated: [],
      events: {},
      logicFields: {},
      contexts: {}
    },
    inputCounter: 0,
    reducerDefaults: defaults,
    wrapperContexts: new WeakMap(),
    buildHeap: [],
    mount: {
      counter: {},
      mounted: {}
    },
    react: {
      contexts: new WeakMap()
    },
    reducers: {
      tree: {},
      roots: {},
      redux: {},
      whitelist: false,
      combined: undefined
    },
    store: undefined,
    __store: undefined,
    options: _extends({
      debug: false,
      proxyFields: true,
      flatDefaults: false,
      attachStrategy: 'dispatch',
      detachStrategy: 'dispatch',
      defaultPath: ['kea', 'logic']
    }, otherOptions)
  };
  Object.defineProperty(newContext, 'store', {
    get: function get() {
      var store = newContext['__store'];
      if (!store && createStoreOptions) {
        return createStore(typeof createStoreOptions === 'object' ? createStoreOptions : {});
      }
      return store;
    },
    set: function set(store) {
      newContext['__store'] = store;
    }
  });
  setContext(newContext);
  activatePlugin(corePlugin);
  runPlugins('afterOpenContext', newContext, options);
  if (plugins) {
    for (var _iterator = _createForOfIteratorHelperLoose(plugins), _step; !(_step = _iterator()).done;) {
      var plugin = _step.value;
      activatePlugin(plugin);
    }
  }
  if (!initial && createStoreOptions) {
    context.store;
  }
  return context;
}
function closeContext() {
  if (context) {
    runPlugins('beforeCloseContext', context);
  }
  context = undefined;
}
function resetContext(options, initial) {
  if (options === void 0) {
    options = {};
  }
  if (initial === void 0) {
    initial = false;
  }
  if (context) {
    closeContext();
  }
  return openContext(options, initial);
}
function getPluginContext(name) {
  var _getContext = getContext(),
    plugins = _getContext.plugins;
  if (!plugins.contexts[name]) {
    plugins.contexts[name] = {};
  }
  return plugins.contexts[name];
}
function setPluginContext(name, pluginContext) {
  var _getContext2 = getContext(),
    plugins = _getContext2.plugins;
  plugins.contexts[name] = pluginContext;
}

function events(input) {
  return function (logic) {
    var events = typeof input === 'function' ? input(logic) : input;
    var _loop = function _loop() {
      var key = _Object$keys[_i];
      var event = events[key];
      var newEvent = Array.isArray(event) ? function (props, oldProps) {
        return event.forEach(function (e) {
          return e(props, oldProps);
        });
      } : event;
      if (logic.events[key]) {
        var oldEvent = logic.events[key];
        logic.events[key] = function (props, oldProps) {
          oldEvent === null || oldEvent === void 0 ? void 0 : oldEvent(props, oldProps);
          newEvent === null || newEvent === void 0 ? void 0 : newEvent(props, oldProps);
        };
      } else if (newEvent) {
        logic.events[key] = newEvent;
      }
    };
    for (var _i = 0, _Object$keys = Object.keys(events); _i < _Object$keys.length; _i++) {
      _loop();
    }
  };
}
function afterMount(input) {
  return events(function (logic) {
    return {
      afterMount: function afterMount() {
        return input(logic);
      }
    };
  });
}
function beforeUnmount(input) {
  return events(function (logic) {
    return {
      beforeUnmount: function beforeUnmount() {
        return input(logic);
      }
    };
  });
}
function propsChanged(input) {
  return events(function (logic) {
    return {
      propsChanged: function propsChanged(props, oldProps) {
        return input(logic, oldProps);
      }
    };
  });
}

var LISTENERS_BREAKPOINT = 'kea-listeners breakpoint broke';
var isBreakpoint = function isBreakpoint(error) {
  return error.message === LISTENERS_BREAKPOINT;
};
function listeners(input) {
  return function (logic) {
    var _logic$cache, _logic$cache$listener, _logic$cache2, _logic$cache2$listene;
    if (!logic.listeners) {
      logic.listeners = {};
      afterMount(function () {
        addListeners(logic);
      })(logic);
      beforeUnmount(function () {
        removeListeners(logic);
        if (logic.cache.listenerBreakpointCounter) {
          for (var _i = 0, _Object$keys = Object.keys(logic.cache.listenerBreakpointCounter); _i < _Object$keys.length; _i++) {
            var key = _Object$keys[_i];
            logic.cache.listenerBreakpointCounter[key] += 1;
          }
        }
      })(logic);
    }
    (_logic$cache$listener = (_logic$cache = logic.cache).listenerBreakpointCounter) !== null && _logic$cache$listener !== void 0 ? _logic$cache$listener : _logic$cache.listenerBreakpointCounter = {};
    (_logic$cache2$listene = (_logic$cache2 = logic.cache).listenerLastDispatchId) !== null && _logic$cache2$listene !== void 0 ? _logic$cache2$listene : _logic$cache2.listenerLastDispatchId = {};
    var listeners = typeof input === 'function' ? input(logic) : input;
    var _getContext = getContext(),
      contextId = _getContext.contextId;
    var _loop = function _loop() {
      var actionKey = _Object$keys2[_i2];
      var listenerArray = Array.isArray(listeners[actionKey]) ? listeners[actionKey] : [listeners[actionKey]];
      var key = actionKey;
      if (typeof logic.actions[key] !== 'undefined') {
        key = logic.actions[key].toString();
      }
      var start = logic.listeners[key] ? logic.listeners[key].length : 0;
      var listenerWrapperArray = listenerArray.map(function (listener, index) {
        var listenerKey = contextId + "/" + key + "/" + (start + index);
        return function (action, previousState) {
          var breakCounter = (logic.cache.listenerBreakpointCounter[listenerKey] || 0) + 1;
          logic.cache.listenerBreakpointCounter[listenerKey] = breakCounter;
          logic.cache.listenerLastDispatchId[listenerKey] = action.dispatchId;
          var throwIfCalled = function throwIfCalled() {
            if (logic.cache.listenerBreakpointCounter[listenerKey] !== breakCounter || contextId !== getContext().contextId) {
              var error = new Error(LISTENERS_BREAKPOINT);
              error.__keaDispatchId = logic.cache.listenerLastDispatchId[listenerKey];
              throw error;
            }
          };
          var breakpoint = function breakpoint(ms) {
            if (typeof ms !== 'undefined') {
              return new Promise(function (resolve) {
                return setTimeout(resolve, ms);
              }).then(function () {
                throwIfCalled();
              });
            } else {
              throwIfCalled();
            }
          };
          var response;
          try {
            response = listener(action.payload, breakpoint, action, previousState);
            if (response && response.then && typeof response.then === 'function') {
              trackPendingListener(logic, actionKey, response);
              if (action.dispatchId) {
                addDispatchListener(action.dispatchId, response);
              }
              return response["catch"](function (e) {
                if (e.message !== LISTENERS_BREAKPOINT) {
                  throw e;
                }
              })["finally"](function () {
                removeDispatchListener(action.dispatchId, response);
              });
            }
          } catch (e) {
            if (e.message !== LISTENERS_BREAKPOINT) {
              throw e;
            }
          }
          return response;
        };
      });
      if (logic.listeners[key]) {
        logic.listeners[key] = [].concat(logic.listeners[key], listenerWrapperArray);
      } else {
        logic.listeners[key] = listenerWrapperArray;
      }
    };
    for (var _i2 = 0, _Object$keys2 = Object.keys(listeners); _i2 < _Object$keys2.length; _i2++) {
      _loop();
    }
  };
}
function sharedListeners(input) {
  return function (logic) {
    logic.sharedListeners = _extends({}, logic.sharedListeners || {}, typeof input === 'function' ? input(logic) : input);
  };
}
function addListeners(logic) {
  var _logic$listeners;
  var _getPluginContext = getPluginContext('listeners'),
    byPath = _getPluginContext.byPath,
    byAction = _getPluginContext.byAction;
  byPath[logic.pathString] = (_logic$listeners = logic.listeners) !== null && _logic$listeners !== void 0 ? _logic$listeners : {};
  for (var _i3 = 0, _Object$entries = Object.entries((_logic$listeners2 = logic.listeners) !== null && _logic$listeners2 !== void 0 ? _logic$listeners2 : {}); _i3 < _Object$entries.length; _i3++) {
    var _logic$listeners2, _logic$actionTypes$ke;
    var _Object$entries$_i = _Object$entries[_i3],
      key = _Object$entries$_i[0],
      listenerArray = _Object$entries$_i[1];
    var type = (_logic$actionTypes$ke = logic.actionTypes[key]) !== null && _logic$actionTypes$ke !== void 0 ? _logic$actionTypes$ke : key;
    if (!byAction[type]) {
      byAction[type] = {};
    }
    byAction[type][logic.pathString] = listenerArray;
  }
}
function removeListeners(logic) {
  var _getPluginContext2 = getPluginContext('listeners'),
    byPath = _getPluginContext2.byPath,
    byAction = _getPluginContext2.byAction;
  for (var _i4 = 0, _Object$keys3 = Object.keys((_logic$listeners3 = logic.listeners) !== null && _logic$listeners3 !== void 0 ? _logic$listeners3 : {}); _i4 < _Object$keys3.length; _i4++) {
    var _logic$listeners3, _logic$actionTypes$ke2;
    var key = _Object$keys3[_i4];
    var type = (_logic$actionTypes$ke2 = logic.actionTypes[key]) !== null && _logic$actionTypes$ke2 !== void 0 ? _logic$actionTypes$ke2 : key;
    if (byAction[type]) {
      delete byAction[type][logic.pathString];
      if (Object.keys(byAction[type]).length === 0) {
        delete byAction[type];
      }
    }
  }
  delete byPath[logic.pathString];
}
function trackPendingListener(logic, actionKey, response) {
  var _getPluginContext3 = getPluginContext('listeners'),
    pendingPromises = _getPluginContext3.pendingPromises;
  pendingPromises.set(response, [logic, actionKey]);
  var remove = function remove() {
    pendingPromises["delete"](response);
  };
  response.then(remove)["catch"](remove);
}
function addDispatchListener(dispatchId, response) {
  var _getPluginContext4 = getPluginContext('listeners'),
    pendingDispatches = _getPluginContext4.pendingDispatches;
  var dispatches = pendingDispatches.get(dispatchId);
  if (dispatches) {
    dispatches.add(response);
  } else {
    pendingDispatches.set(dispatchId, new Set([response]));
  }
}
function removeDispatchListener(dispatchId, response) {
  var _getPluginContext5 = getPluginContext('listeners'),
    pendingDispatches = _getPluginContext5.pendingDispatches;
  var dispatches = pendingDispatches.get(dispatchId);
  if (dispatches) {
    dispatches["delete"](response);
    if (dispatches.size === 0) {
      pendingDispatches["delete"](dispatchId);
    }
  }
}

var asyncCounter = 0;
var nextDispatchId = function nextDispatchId() {
  return String(++asyncCounter);
};
function actions(input) {
  return function (logic) {
    var actions = typeof input === 'function' ? input(logic) : input;
    var _loop = function _loop() {
      var _Object$entries$_i = _Object$entries[_i],
        key = _Object$entries$_i[0],
        payloadCreator = _Object$entries$_i[1];
      var actionCreator = typeof payloadCreator === 'function' && '_isKeaAction' in payloadCreator ? payloadCreator : createActionCreator(createActionType(key, logic.pathString), payloadCreator !== null && payloadCreator !== void 0 ? payloadCreator : true);
      var type = actionCreator.toString();
      var _getContext = getContext(),
        disableAsyncActions = _getContext.options.disableAsyncActions;
      logic.actionCreators[key] = actionCreator;
      logic.actions[key] = function () {
        var builtAction = actionCreator.apply(void 0, arguments);
        getContext().store.dispatch(disableAsyncActions ? builtAction : _extends({}, builtAction, {
          dispatchId: nextDispatchId()
        }));
      };
      logic.actions[key].toString = function () {
        return type;
      };
      if (!disableAsyncActions) {
        logic.asyncActions[key] = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
          var builtAction,
            dispatchId,
            _getPluginContext,
            pendingDispatches,
            promises,
            responses,
            _args = arguments,
            _t;
          return _regenerator().w(function (_context) {
            while (1) switch (_context.p = _context.n) {
              case 0:
                builtAction = actionCreator.apply(void 0, _args);
                dispatchId = nextDispatchId();
                getContext().store.dispatch(_extends({}, builtAction, {
                  dispatchId: dispatchId
                }));
                _getPluginContext = getPluginContext('listeners'), pendingDispatches = _getPluginContext.pendingDispatches;
              case 1:
                promises = pendingDispatches.get(dispatchId);
                if (promises) {
                  _context.n = 2;
                  break;
                }
                return _context.a(2);
              case 2:
                _context.p = 2;
                _context.n = 3;
                return Promise.all(promises);
              case 3:
                responses = _context.v;
                return _context.a(2, responses[0]);
              case 4:
                _context.p = 4;
                _t = _context.v;
                if (!isBreakpoint(_t)) {
                  _context.n = 5;
                  break;
                }
                if ('__keaDispatchId' in _t) {
                  dispatchId = _t.__keaDispatchId;
                }
                _context.n = 6;
                break;
              case 5:
                throw _t;
              case 6:
                _context.n = 1;
                break;
              case 7:
                return _context.a(2);
            }
          }, _callee, null, [[2, 4]]);
        }));
        logic.asyncActions[key].toString = function () {
          return type;
        };
      }
      logic.actionKeys[type] = key;
      logic.actionTypes[key] = type;
    };
    for (var _i = 0, _Object$entries = Object.entries(actions); _i < _Object$entries.length; _i++) {
      _loop();
    }
  };
}
function createActionCreator(type, payloadCreator) {
  var action = function action() {
    return {
      type: type,
      payload: typeof payloadCreator === 'function' ? payloadCreator.apply(void 0, arguments) : {
        value: true
      }
    };
  };
  action.toString = function () {
    return type;
  };
  action._isKeaAction = true;
  return action;
}
function createActionType(key, pathString) {
  var toSpaces = function toSpaces(key) {
    return key.replace(/(?:^|\.?)([A-Z])/g, function (x, y) {
      return ' ' + y.toLowerCase();
    }).replace(/^ /, '');
  };
  return toSpaces(key) + " (" + pathString + ")";
}

function connect(input) {
  return function (logic) {
    var props = logic.props || {};
    var connect = typeof input === 'function' ? input(props) : input;
    var connectLogic = Array.isArray(connect) ? connect : '_isKeaBuild' in connect || '_isKea' in connect ? [connect] : connect.logic;
    if (connectLogic) {
      for (var _iterator = _createForOfIteratorHelperLoose(connectLogic), _step; !(_step = _iterator()).done;) {
        var otherLogic = _step.value;
        if ('_isKea' in otherLogic) {
          otherLogic = otherLogic(props);
        }
        addConnection(logic, otherLogic);
      }
    }
    if ('_isKeaBuild' in connect || '_isKea' in connect || Array.isArray(connect)) {
      return;
    }
    if (connect.actions) {
      var response = deconstructMapping(connect.actions);
      var _loop = function _loop() {
        var _step2$value = _step2.value,
          otherLogic = _step2$value[0],
          from = _step2$value[1],
          to = _step2$value[2];
        if (typeof otherLogic !== 'function' && typeof otherLogic !== 'object') {
          throw new Error("[KEA] Logic \"" + logic.pathString + "\" can not connect to " + typeof otherLogic + " to request action \"" + from + "\"");
        }
        if (isLogicWrapper(otherLogic)) {
          otherLogic = otherLogic.build(props);
        }
        if (isBuiltLogic(otherLogic)) {
          addConnection(logic, otherLogic);
          if (getContext().buildHeap.includes(otherLogic)) {
            logic.actionCreators[to] = function () {
              var _otherLogic$actionCre;
              return (_otherLogic$actionCre = otherLogic.actionCreators)[from].apply(_otherLogic$actionCre, arguments);
            };
            logic.actionCreators[to].toString = function () {
              return createActionType(from, otherLogic.pathString);
            };
            logic.actionTypes[to] = logic.actionCreators[to].toString();
          } else {
            logic.actionCreators[to] = otherLogic.actionCreators[from];
            logic.actionTypes[to] = otherLogic.actionTypes[from];
          }
        } else {
          logic.actionCreators[to] = otherLogic[from];
          if (logic.actionCreators[to]._isKeaAction) {
            logic.actionTypes[to] = logic.actionCreators[to].toString();
          } else {
            logic.actionTypes[to] = logic.actionCreators[to]().type;
          }
        }
        logic.actionKeys[logic.actionTypes[to]] = to;
        if (typeof logic.actionCreators[to] === 'undefined') {
          throw new Error("[KEA] Logic \"" + logic.pathString + "\", connecting to action \"" + from + "\" returns 'undefined'");
        }
        logic.actions[to] = function () {
          var _logic$actionCreators;
          var builtAction = (_logic$actionCreators = logic.actionCreators)[to].apply(_logic$actionCreators, arguments);
          getContext().store.dispatch(builtAction);
        };
        logic.actions[to].toString = function () {
          return logic.actionTypes[to];
        };
      };
      for (var _iterator2 = _createForOfIteratorHelperLoose(response), _step2; !(_step2 = _iterator2()).done;) {
        _loop();
      }
    }
    if (connect.values) {
      var _response = deconstructMapping(connect.values);
      var _loop2 = function _loop2() {
        var _step3$value = _step3.value,
          otherLogic = _step3$value[0],
          from = _step3$value[1],
          to = _step3$value[2];
        if (typeof otherLogic !== 'function' && typeof otherLogic !== 'object') {
          throw new Error("[KEA] Logic \"" + logic.pathString + "\" can not connect to " + typeof otherLogic + " to request prop \"" + from + "\"");
        }
        if (isLogicWrapper(otherLogic)) {
          otherLogic = otherLogic(props);
        }
        if (isBuiltLogic(otherLogic)) {
          addConnection(logic, otherLogic);
          var selector = from === '*' ? otherLogic.selector : otherLogic.selectors[from];
          var throwError = function throwError() {
            throw new Error("Connected selector \"" + to + "\" on logic \"" + logic.pathString + "\" is undefined.");
          };
          if (selector) {
            logic.selectors[to] = selector;
          } else if (getContext().buildHeap.includes(otherLogic)) {
            logic.selectors[to] = function (state, props) {
              return otherLogic.selectors[from] ? otherLogic.selectors[from](state, props) : throwError();
            };
          } else {
            throwError();
          }
        } else if (typeof otherLogic === 'function') {
          logic.selectors[to] = from === '*' ? otherLogic : function (state, props) {
            var values = otherLogic(state, props);
            return values && values[from];
          };
        }
        if (logic.selectors[to] && !logic.values.hasOwnProperty(to)) {
          Object.defineProperty(logic.values, to, {
            get: function get() {
              return logic.selectors[to](getStoreState(), logic.props);
            },
            enumerable: true
          });
        }
      };
      for (var _iterator3 = _createForOfIteratorHelperLoose(_response), _step3; !(_step3 = _iterator3()).done;) {
        _loop2();
      }
    }
  };
}
function deconstructMapping(mapping) {
  if (mapping.length % 2 === 1) {
    console.error(mapping);
    throw new Error("[KEA] Uneven mapping given to connect");
  }
  var response = [];
  for (var i = 0; i < mapping.length; i += 2) {
    var logic = mapping[i];
    var array = mapping[i + 1];
    if (!Array.isArray(array)) {
      console.error(mapping);
      throw new Error('[KEA] Invalid mapping given to connect. Make sure every second element is an array!');
    }
    for (var j = 0; j < array.length; j++) {
      if (array[j].includes(' as ')) {
        var parts = array[j].split(' as ');
        response.push([logic, parts[0], parts[1]]);
      } else {
        response.push([logic, array[j], array[j]]);
      }
    }
  }
  return response;
}
function addConnection(logic, otherLogic) {
  if (!otherLogic.connections || Object.keys(otherLogic.connections).length === 0) {
    return;
  }
  if (logic.connections[otherLogic.pathString]) {
    return;
  }
  Object.keys(otherLogic.connections).forEach(function (path) {
    if (!logic.connections[path]) {
      logic.connections[path] = otherLogic.connections[path];
    }
  });
}

function defaults(input) {
  return function (logic) {
    var defaults = typeof input === 'function' ? input(logic) : input;
    if (typeof defaults === 'function') {
      logic.defaults['*'] = defaults;
    } else if (typeof defaults === 'object') {
      var contextDefaults = getContextDefaults(logic);
      for (var _i = 0, _Object$entries = Object.entries(defaults); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _Object$entries[_i],
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];
        logic.defaults[key] = contextDefaults && typeof contextDefaults[key] !== 'undefined' ? contextDefaults[key] : value;
      }
    } else {
      throw new Error("[KEA] Unknown defaults of type \"" + typeof defaults + "\" for logic \"" + logic.pathString + "\"");
    }
  };
}
function getContextDefaults(logic) {
  var _getContext = getContext(),
    reducerDefaults = _getContext.reducerDefaults;
  if (reducerDefaults && !('_keaAutomaticPath' in logic.path)) {
    if (getContext().options.flatDefaults) {
      if (reducerDefaults[logic.pathString]) {
        return reducerDefaults[logic.pathString];
      }
    } else {
      for (var _iterator = _createForOfIteratorHelperLoose(logic.path), _step; !(_step = _iterator()).done;) {
        var part = _step.value;
        reducerDefaults = reducerDefaults[part.toString()];
        if (typeof reducerDefaults !== 'object') {
          return;
        }
      }
      return reducerDefaults;
    }
  }
}

function selectors(input) {
  return function (logic) {
    var selectorInputs = typeof input === 'function' ? input(logic) : input;
    var builtSelectors = {};
    var _loop = function _loop() {
      var key = _Object$keys[_i];
      if (typeof logic.selectors[key] !== 'undefined') {
        throw new Error("[KEA] Logic \"" + logic.pathString + "\" selector \"" + key + "\" already exists");
      }
      addSelectorAndValue(logic, key, function () {
        return builtSelectors[key].apply(builtSelectors, arguments);
      });
    };
    for (var _i = 0, _Object$keys = Object.keys(selectorInputs); _i < _Object$keys.length; _i++) {
      _loop();
    }
    var propSelectors = typeof Proxy !== 'undefined' ? new Proxy(logic.props, {
      get: function get(target, prop) {
        if (!(prop in target)) {
          throw new Error("[KEA] Prop \"" + String(prop) + "\" not found for logic \"" + logic.pathString + "\". Attempted to use in a selector. Please specify a default via props({ " + String(prop) + ": '' }) to resolve.");
        }
        return function () {
          return target[prop];
        };
      }
    }) : Object.fromEntries(Object.keys(logic.props).map(function (key) {
      return [key, function () {
        return logic.props[key];
      }];
    }));
    var _loop2 = function _loop2() {
      var entry = _Object$entries[_i2];
      var key = entry[0],
        arr = entry[1];
      if (!arr) {
        throw new Error("[KEA] Logic \"" + logic.pathString + "\" selector \"" + key + "\" is undefined");
      }
      var input = arr[0],
        func = arr[1],
        memoizeOptions = arr[2];
      var args = input(logic.selectors, propSelectors);
      if (args.filter(function (a) {
        return typeof a !== 'function';
      }).length > 0) {
        var argTypes = args.map(function (a) {
          return typeof a;
        }).join(', ');
        var msg = "[KEA] Logic \"" + logic.pathString + "\", selector \"" + key + "\" has incorrect input: [" + argTypes + "].";
        throw new Error(msg);
      }
      builtSelectors[key] = createSelector(args, func, {
        memoizeOptions: memoizeOptions
      });
      addSelectorAndValue(logic, key, function (state, props) {
        if (state === void 0) {
          state = getStoreState();
        }
        if (props === void 0) {
          props = logic.props;
        }
        return builtSelectors[key](state, props);
      });
      if (!logic.values.hasOwnProperty(key)) {
        Object.defineProperty(logic.values, key, {
          get: function get() {
            return logic.selectors[key](getStoreState(), logic.props);
          },
          enumerable: true
        });
      }
    };
    for (var _i2 = 0, _Object$entries = Object.entries(selectorInputs); _i2 < _Object$entries.length; _i2++) {
      _loop2();
    }
  };
}
function addSelectorAndValue(logic, key, selector) {
  logic.selectors[key] = selector;
  if (!logic.values.hasOwnProperty(key)) {
    Object.defineProperty(logic.values, key, {
      get: function get() {
        return logic.selectors[key](getStoreState(), logic.props);
      },
      enumerable: true
    });
  }
}

function rootReducer() {
  return function (logic) {
    logic.reducer = function (state, action, fullState) {
      return combineKeaReducers(logic.reducers)(state, action, fullState);
    };
    if (!logic.selector) {
      rootSelector()(logic);
    }
  };
}
function rootSelector() {
  return function (logic) {
    logic.selector = function (state) {
      if (state === void 0) {
        state = getStoreState();
      }
      return pathSelector(logic.path, state);
    };
  };
}
function reducers(input) {
  return function (logic) {
    var reducers = typeof input === 'function' ? input(logic) : input;
    if (!logic.reducer) {
      rootReducer()(logic);
    }
    if (!logic.selector) {
      rootSelector()(logic);
    }
    var contextDefaults = getContextDefaults(logic);
    var _loop = function _loop() {
      var _logic$cache, _logic$cache$reducers, _logic$cache$reducers2, _logic$cache$reducers3;
      var _Object$entries$_i = _Object$entries[_i],
        key = _Object$entries$_i[0],
        object = _Object$entries$_i[1];
      var initialValue;
      var reducerOptions;
      var reducer;
      if (Array.isArray(object)) {
        var _object$, _object$Math$max;
        initialValue = (_object$ = object[0]) !== null && _object$ !== void 0 ? _object$ : null;
        reducer = (_object$Math$max = object[Math.max(1, object.length - 1)]) !== null && _object$Math$max !== void 0 ? _object$Math$max : {};
        if (object.length === 3) {
          reducerOptions = object[1];
        }
      } else if (typeof object === 'object') {
        initialValue = null;
        reducer = object;
      } else {
        throw new Error("[KEA] Logic \"" + logic.pathString + "\" reducer \"" + key + "\" is set to unsupported value");
      }
      if (reducerOptions) {
        var _logic$reducerOptions;
        logic.reducerOptions[key] = _extends({}, (_logic$reducerOptions = logic.reducerOptions[key]) !== null && _logic$reducerOptions !== void 0 ? _logic$reducerOptions : {}, reducerOptions);
      }
      if (typeof logic.defaults[key] === 'undefined') {
        if (contextDefaults && typeof contextDefaults[key] !== 'undefined') {
          logic.defaults[key] = contextDefaults[key];
        } else if (typeof logic.defaults['*'] === 'function') {
          logic.defaults[key] = function (state, props) {
            var v = logic.defaults['*'](state, props)[key];
            return typeof v === 'undefined' ? initialValue : typeof v === 'function' ? v(state, props) : v;
          };
        } else {
          logic.defaults[key] = initialValue;
        }
      }
      (_logic$cache$reducers = (_logic$cache = logic.cache).reducers) !== null && _logic$cache$reducers !== void 0 ? _logic$cache$reducers : _logic$cache.reducers = {};
      (_logic$cache$reducers3 = (_logic$cache$reducers2 = logic.cache.reducers)[key]) !== null && _logic$cache$reducers3 !== void 0 ? _logic$cache$reducers3 : _logic$cache$reducers2[key] = {};
      var mapping = logic.cache.reducers[key];
      for (var _i2 = 0, _Object$keys = Object.keys((_reducer = reducer) !== null && _reducer !== void 0 ? _reducer : {}); _i2 < _Object$keys.length; _i2++) {
        var _reducer;
        var _key = _Object$keys[_i2];
        var mappingKey = logic.actions[_key] ? logic.actions[_key].toString() : _key;
        mapping[mappingKey] = reducer[_key];
      }
      if (typeof mapping['undefined'] !== 'undefined' && typeof logic.actions['undefined'] === 'undefined') {
        throw new Error("[KEA] Logic \"" + logic.pathString + "\" reducer \"" + key + "\" is waiting for an action that is undefined: [" + Object.keys(mapping).join(', ') + "]");
      }
      if (!logic.reducers[key] && logic.selectors[key]) {
        throw new Error("[KEA] Logic \"" + logic.pathString + "\" can't add reducer \"" + key + "\" because a selector with the same name exists.");
      }
      if (Object.keys(mapping).length === 0) {
        logic.reducers[key] = function () {
          return logic.defaults[key];
        };
      } else {
        logic.reducers[key] = function (state, action, fullState) {
          if (typeof state === 'undefined') {
            state = getDefaultState(logic.defaults[key], fullState, key, logic);
          }
          if (mapping[action.type]) {
            return mapping[action.type](state, action.payload, action.meta);
          } else if (logic.actionKeys[action.type] && mapping[logic.actionKeys[action.type]]) {
            return mapping[logic.actionKeys[action.type]](state, action.payload, action.meta);
          } else {
            return state;
          }
        };
      }
      if (!logic.selectors[key]) {
        addSelectorAndValue(logic, key, createSelector(logic.selector, function (state) {
          return state[key];
        }));
      }
    };
    for (var _i = 0, _Object$entries = Object.entries(reducers); _i < _Object$entries.length; _i++) {
      _loop();
    }
  };
}
function getDefaultState(defaultValue, fullState, key, logic) {
  if (typeof defaultValue === 'function') {
    if (fullState) {
      return defaultValue(fullState, logic.props);
    } else {
      console.error("[KEA] Store not initialized and can't get default value of \"" + key + "\" in \"" + logic.pathString + "\"");
      return undefined;
    }
  }
  return defaultValue;
}
function pathSelector(path, state) {
  return [state].concat(path).reduce(function (v, a) {
    if (a in v) {
      return v[a];
    }
    throw new Error("[KEA] Can not find path \"" + path.join('.') + "\" in the store.");
  });
}

function key(input) {
  return function (logic) {
    var key = input(logic.props);
    if (typeof logic.keyBuilder !== 'undefined') {
      throw new Error("[KEA] Already defined key builder for logic \"" + logic.pathString + "\".");
    }
    if (typeof key === 'undefined') {
      throw new Error("[KEA] Undefined key for logic \"" + logic.pathString + "\"");
    }
    if (Object.keys(logic.actions).length > 0) {
      throw new Error("[KEA] Can not add key to logic \"" + logic.pathString + "\" after adding actions: " + Object.keys(logic.actions).join(', '));
    }
    logic.key = key;
    logic.keyBuilder = input;
    var isAutomaticPath = '_keaAutomaticPath' in logic.path;
    logic.path = [].concat(logic.path, [logic.key]);
    logic.pathString = logic.path.join('.');
    if (isAutomaticPath) {
      logic.path['_keaAutomaticPath'] = true;
    }
  };
}

function props(input) {
  return function (logic) {
    var newProps = _extends({}, input, logic.props);
    if (!shallowCompare(logic.props, newProps)) {
      logic.lastProps = newProps;
      Object.assign(logic.props, newProps);
    }
  };
}

function path(input) {
  return function (logic) {
    if (logic.path && !('_keaAutomaticPath' in logic.path)) {
      return;
    }
    if (Object.keys(logic.actions).length > 0) {
      throw new Error("[KEA] Can not add path to logic \"" + logic.pathString + "\" after adding actions: " + Object.keys(logic.actions).join(', '));
    }
    if (typeof input === 'function') {
      logic.path = input(logic.key).filter(function (l) {
        return typeof l !== 'undefined';
      });
    } else {
      logic.path = typeof logic.key !== 'undefined' ? [].concat(input, [logic.key]) : input;
    }
    logic.pathString = logic.path.join('.');
  };
}

var corePlugin = {
  name: 'core',
  defaults: function defaults() {
    return {
      actionCreators: {},
      actionKeys: {},
      actionTypes: {},
      actions: {},
      asyncActions: {},
      cache: {},
      connections: {},
      defaults: {},
      listeners: undefined,
      reducers: {},
      reducer: undefined,
      reducerOptions: {},
      selector: undefined,
      selectors: {},
      sharedListeners: undefined,
      values: {},
      events: {}
    };
  },
  events: {
    afterPlugin: function afterPlugin() {
      setPluginContext('listeners', {
        byAction: {},
        byPath: {},
        pendingPromises: new Map(),
        pendingDispatches: new Map()
      });
    },
    beforeReduxStore: function beforeReduxStore(options) {
      options.middleware.push(function (store) {
        return function (next) {
          return function (action) {
            var previousState = store.getState();
            var response = next(action);
            var _getPluginContext = getPluginContext('listeners'),
              byAction = _getPluginContext.byAction;
            var listeners = byAction[action.type];
            if (listeners) {
              for (var _i = 0, _Object$values = Object.values(listeners); _i < _Object$values.length; _i++) {
                var listenerArray = _Object$values[_i];
                for (var _iterator = _createForOfIteratorHelperLoose(listenerArray), _step; !(_step = _iterator()).done;) {
                  var innerListener = _step.value;
                  innerListener(action, previousState);
                }
              }
            }
            return response;
          };
        };
      });
    },
    legacyBuild: function legacyBuild(logic, input) {
      'connect' in input && input.connect && connect(input.connect)(logic);
      runPlugins('legacyBuildAfterConnect', logic, input);
      'actions' in input && input.actions && actions(input.actions)(logic);
      'defaults' in input && input.defaults && defaults(input.defaults)(logic);
      runPlugins('legacyBuildAfterDefaults', logic, input);
      'reducers' in input && input.reducers && reducers(input.reducers)(logic);
      'selectors' in input && input.selectors && selectors(input.selectors)(logic);
      'sharedListeners' in input && sharedListeners(input.sharedListeners)(logic);
      'listeners' in input && input.listeners && listeners(input.listeners)(logic);
      'events' in input && input.events && events(input.events)(logic);
    }
  }
};

function mountLogic(logic, count) {
  if (count === void 0) {
    count = 1;
  }
  var _getContext = getContext(),
    _getContext$mount = _getContext.mount,
    counter = _getContext$mount.counter,
    mounted = _getContext$mount.mounted;
  var pathStrings = Object.keys(logic.connections).filter(function (k) {
    return k !== logic.pathString;
  }).concat([logic.pathString]);
  for (var _iterator = _createForOfIteratorHelperLoose(pathStrings), _step; !(_step = _iterator()).done;) {
    var pathString = _step.value;
    counter[pathString] = (counter[pathString] || 0) + count;
    if (counter[pathString] === count) {
      var _connectedLogic$event, _connectedLogic$event2, _connectedLogic$event3, _connectedLogic$event4;
      var connectedLogic = logic.connections[pathString];
      if (typeof connectedLogic === 'undefined') {
        throw new Error("[KEA] Can not find connected logic at \"" + pathString + "\". Got \"undefined\" instead of the logic when trying to mount \"" + logic.pathString + "\".");
      }
      runPlugins('beforeMount', connectedLogic);
      (_connectedLogic$event = (_connectedLogic$event2 = connectedLogic.events).beforeMount) === null || _connectedLogic$event === void 0 ? void 0 : _connectedLogic$event.call(_connectedLogic$event2);
      mounted[pathString] = connectedLogic;
      if (connectedLogic.reducer) {
        attachReducer(connectedLogic);
      }
      runPlugins('afterMount', connectedLogic);
      (_connectedLogic$event3 = (_connectedLogic$event4 = connectedLogic.events).afterMount) === null || _connectedLogic$event3 === void 0 ? void 0 : _connectedLogic$event3.call(_connectedLogic$event4);
    }
  }
}
function unmountLogic(logic) {
  var _getContext2 = getContext(),
    _getContext2$mount = _getContext2.mount,
    counter = _getContext2$mount.counter,
    mounted = _getContext2$mount.mounted;
  var pathStrings = Object.keys(logic.connections).filter(function (k) {
    return k !== logic.pathString;
  }).concat([logic.pathString]).reverse();
  for (var _iterator2 = _createForOfIteratorHelperLoose(pathStrings), _step2; !(_step2 = _iterator2()).done;) {
    var pathString = _step2.value;
    counter[pathString] = (counter[pathString] || 0) - 1;
    if (counter[pathString] === 0) {
      var _connectedLogic$event5, _connectedLogic$event6, _connectedLogic$event7, _connectedLogic$event8, _getContext$wrapperCo;
      var connectedLogic = logic.connections[pathString];
      runPlugins('beforeUnmount', connectedLogic);
      (_connectedLogic$event5 = (_connectedLogic$event6 = connectedLogic.events).beforeUnmount) === null || _connectedLogic$event5 === void 0 ? void 0 : _connectedLogic$event5.call(_connectedLogic$event6);
      delete mounted[pathString];
      delete counter[pathString];
      if (connectedLogic.reducer) {
        detachReducer(connectedLogic);
      }
      runPlugins('afterUnmount', connectedLogic);
      (_connectedLogic$event7 = (_connectedLogic$event8 = connectedLogic.events).afterUnmount) === null || _connectedLogic$event7 === void 0 ? void 0 : _connectedLogic$event7.call(_connectedLogic$event8);
      (_getContext$wrapperCo = getContext().wrapperContexts.get(logic.wrapper)) === null || _getContext$wrapperCo === void 0 ? void 0 : _getContext$wrapperCo.builtLogics["delete"](logic.key);
    }
  }
}

function applyInputToLogic(logic, input) {
  runPlugins('beforeLogic', logic, input);
  if (typeof input === 'function') {
    input(logic);
  } else {
    'props' in input && props(input.props)(logic);
    'key' in input && typeof input.key !== 'undefined' && key(input.key)(logic);
    'path' in input && input.path && path(input.path)(logic);
    if (input.inherit) {
      for (var _iterator = _createForOfIteratorHelperLoose(input.inherit), _step; !(_step = _iterator()).done;) {
        var inheritLogic = _step.value;
        for (var _iterator2 = _createForOfIteratorHelperLoose(inheritLogic.inputs), _step2; !(_step2 = _iterator2()).done;) {
          var inheritInput = _step2.value;
          applyInputToLogic(logic, inheritInput);
        }
      }
    }
    runPlugins('legacyBuild', logic, input);
    if (input.extend) {
      for (var _iterator3 = _createForOfIteratorHelperLoose(input.extend), _step3; !(_step3 = _iterator3()).done;) {
        var innerInput = _step3.value;
        applyInputToLogic(logic, innerInput);
      }
    }
  }
  runPlugins('afterLogic', logic, input);
  return logic;
}
function getBuiltLogic(wrapper, props) {
  var wrapperContext = getWrapperContext(wrapper);
  if (wrapperContext.isBuilding) {
    throw new Error("[KEA] Circular build detected.");
  }
  var cachedLogic = getCachedBuiltLogicByProps(wrapper, props);
  if (cachedLogic) {
    var prevPropsClone = null;
    if (props && (!cachedLogic.props || cachedLogic.lastProps !== props && (!shallowCompare(cachedLogic.lastProps, props) || !shallowCompare(cachedLogic.props, _extends({}, cachedLogic.props, props))))) {
      prevPropsClone = _extends({}, cachedLogic.props);
      Object.assign(cachedLogic.props, props);
      cachedLogic.lastProps = props;
    }
    if (prevPropsClone && cachedLogic.events.propsChanged) {
      var newPropsClone = _extends({}, cachedLogic.props);
      batchChanges(function () {
        var _cachedLogic$events$p, _cachedLogic$events;
        (_cachedLogic$events$p = (_cachedLogic$events = cachedLogic.events).propsChanged) === null || _cachedLogic$events$p === void 0 ? void 0 : _cachedLogic$events$p.call(_cachedLogic$events, newPropsClone, prevPropsClone);
      });
    }
    return cachedLogic;
  }
  var uniqueId = ++getContext().inputCounter;
  var path = [].concat(getContext().options.defaultPath, [uniqueId]);
  path['_keaAutomaticPath'] = true;
  wrapperContext.isBuilding = true;
  var logic = {
    _isKeaBuild: true,
    key: undefined,
    keyBuilder: undefined,
    path: path,
    pathString: path.join('.'),
    props: _extends({}, props),
    lastProps: props !== null && props !== void 0 ? props : {},
    wrapper: wrapper,
    extend: function extend(input) {
      return applyInputToLogic(logic, input);
    },
    mount: function mount() {
      if (wrapperContext.isBuilding) {
        throw new Error("[KEA] Tried to mount logic \"" + logic.pathString + "\" before it finished building");
      }
      mountLogic(logic);
      var unmounted = false;
      return function () {
        if (unmounted) {
          throw new Error("[KEA] Tried to unmount logic \"" + logic.pathString + "\" for a second time");
        }
        unmountLogic(logic);
        unmounted = true;
      };
    },
    unmount: function unmount() {
      return unmountLogic(logic);
    },
    isMounted: function isMounted() {
      var counter = getContext().mount.counter[logic.pathString];
      return typeof counter === 'number' && counter > 0;
    }
  };
  var _getContext = getContext(),
    buildHeap = _getContext.buildHeap;
  try {
    buildHeap.push(logic);
    for (var _iterator4 = _createForOfIteratorHelperLoose(getContext().plugins.activated), _step4; !(_step4 = _iterator4()).done;) {
      var plugin = _step4.value;
      if (plugin.defaults) {
        var newLogicProperties = typeof plugin.defaults === 'function' ? plugin.defaults() : plugin.defaults;
        Object.assign(logic, newLogicProperties);
      }
    }
    runPlugins('beforeBuild', logic, wrapper.inputs);
    for (var _iterator5 = _createForOfIteratorHelperLoose(wrapper.inputs), _step5; !(_step5 = _iterator5()).done;) {
      var input = _step5.value;
      applyInputToLogic(logic, input);
    }
    logic.connections[logic.pathString] = logic;
    wrapperContext.keyBuilder = logic.keyBuilder;
    wrapperContext.builtLogics.set(logic.key, logic);
    runPlugins('afterBuild', logic, wrapper.inputs);
  } catch (e) {
    throw e;
  } finally {
    wrapperContext.isBuilding = false;
    buildHeap.pop();
  }
  if (buildHeap.length > 0) {
    if (!buildHeap[buildHeap.length - 1].connections[logic.pathString]) {
      addConnection(buildHeap[buildHeap.length - 1], logic);
    }
  }
  return logic;
}
function getCachedBuiltLogicByKey(wrapper, key) {
  var wrapperContext = getWrapperContext(wrapper);
  var builtLogic = wrapperContext.builtLogics.get(key);
  return builtLogic !== null && builtLogic !== void 0 ? builtLogic : null;
}
function getCachedBuiltLogicByProps(wrapper, props) {
  var _wrapperContext$keyBu;
  var wrapperContext = getWrapperContext(wrapper);
  return getCachedBuiltLogicByKey(wrapper, wrapperContext === null || wrapperContext === void 0 ? void 0 : (_wrapperContext$keyBu = wrapperContext.keyBuilder) === null || _wrapperContext$keyBu === void 0 ? void 0 : _wrapperContext$keyBu.call(wrapperContext, props !== null && props !== void 0 ? props : {}));
}
function getWrapperContext(wrapper) {
  var _getContext2 = getContext(),
    wrapperContexts = _getContext2.wrapperContexts;
  var wrapperContext = wrapperContexts.get(wrapper);
  if (!wrapperContext) {
    wrapperContext = {
      keyBuilder: undefined,
      builtLogics: new Map(),
      isBuilding: false
    };
    wrapperContexts.set(wrapper, wrapperContext);
  }
  return wrapperContext;
}

function wrapComponent(Component, wrapper) {
  runPlugins('beforeWrap', wrapper, Component);
  injectActionsIntoClass(Component);
  var Kea = function Kea(props) {
    var _props$actions;
    var logic = wrapper.build(props);
    var values = useAllValues(logic);
    var actions = _extends({}, (_props$actions = props.actions) !== null && _props$actions !== void 0 ? _props$actions : {}, useActions(logic));
    runPlugins('beforeRender', logic, props);
    return /*#__PURE__*/React$1.createElement(Component, _extends({}, props, values, {
      dispatch: getContext().store.dispatch,
      actions: actions
    }));
  };
  Kea._wrapper = wrapper;
  Kea._wrappedComponent = Component;
  runPlugins('afterWrap', wrapper, Component, Kea);
  return Kea;
}
function injectActionsIntoClass(Component) {
  function isStateless(Component) {
    return typeof Component === 'function' && !(Component.prototype && Component.prototype.isReactComponent);
  }
  if (!isStateless(Component)) {
    if (!Object.getOwnPropertyDescriptor(Component.prototype, 'actions')) {
      Object.defineProperty(Component.prototype, 'actions', {
        get: function actions() {
          return this.props.actions;
        }
      });
    }
  }
}

function kea(input) {
  var _wrapper = function wrapper(props) {
    if (typeof props === 'object' || typeof props === 'undefined') {
      return _wrapper.build(props);
    }
    return _wrapper.wrap(props);
  };
  _wrapper._isKea = true;
  _wrapper.inputs = Array.isArray(input) ? input : [input];
  _wrapper.wrap = function (Component) {
    return wrapComponent(Component, _wrapper);
  };
  _wrapper.build = function (props) {
    return getBuiltLogic(_wrapper, props);
  };
  _wrapper.mount = function () {
    return _wrapper.build().mount();
  };
  _wrapper.unmount = function () {
    return _wrapper.build().unmount();
  };
  _wrapper.isMounted = function (keyOrProps) {
    return !!_wrapper.findMounted(keyOrProps);
  };
  _wrapper.findMounted = function (keyOrProps) {
    try {
      return _wrapper.find(keyOrProps);
    } catch (e) {
      return null;
    }
  };
  _wrapper.findAllMounted = function () {
    var wrapperContext = getContext().wrapperContexts.get(_wrapper);
    var found = [];
    if (!wrapperContext) {
      return found;
    }
    var _getContext = getContext(),
      counter = _getContext.mount.counter;
    for (var _iterator = _createForOfIteratorHelperLoose(wrapperContext.builtLogics.values()), _step; !(_step = _iterator()).done;) {
      var logic = _step.value;
      if (counter[logic.pathString] > 0) {
        found.push(logic);
      }
    }
    return found;
  };
  _wrapper.find = function (keyOrProps) {
    var _builtLogic$pathStrin;
    var builtLogic = typeof keyOrProps === 'object' || typeof keyOrProps === 'undefined' ? getCachedBuiltLogicByProps(_wrapper, keyOrProps) : getCachedBuiltLogicByKey(_wrapper, keyOrProps);
    if (builtLogic && getContext().mount.counter[builtLogic.pathString] > 0) {
      return builtLogic;
    }
    var keyString = typeof keyOrProps !== 'undefined' ? " with " + (typeof keyOrProps === 'object' ? 'props' : 'key') + " " + JSON.stringify(keyOrProps) : '';
    throw new Error("[KEA] Can not find mounted " + ((_builtLogic$pathStrin = builtLogic === null || builtLogic === void 0 ? void 0 : builtLogic.pathString) !== null && _builtLogic$pathStrin !== void 0 ? _builtLogic$pathStrin : 'logic') + keyString);
  };
  _wrapper.extend = function (extendedInput) {
    var wrapperContext = getContext().wrapperContexts.get(_wrapper);
    if (wrapperContext) {
      throw new Error("[KEA] Can not extend logic once it has been built.");
    }
    if (Array.isArray(extendedInput)) {
      _wrapper.inputs = _wrapper.inputs.concat(extendedInput);
    } else {
      _wrapper.inputs.push(extendedInput);
    }
    return _wrapper;
  };
  if (getContext().options.proxyFields) {
    proxyFields(_wrapper);
  }
  return _wrapper;
}
function proxyFieldToLogic(wrapper, key) {
  if (!wrapper.hasOwnProperty(key)) {
    Object.defineProperty(wrapper, key, {
      get: function get() {
        var logic = wrapper.findMounted();
        if (!logic && getContext().buildHeap.length > 0) {
          logic = wrapper.build();
        }
        if (logic) {
          return logic[key];
        } else {
          throw new Error(unmountedActionError(String(key), wrapper.build().pathString));
        }
      }
    });
  }
}
function proxyFields(wrapper) {
  var reservedProxiedKeys = ['path', 'pathString', 'props'];
  for (var _i = 0, _reservedProxiedKeys = reservedProxiedKeys; _i < _reservedProxiedKeys.length; _i++) {
    var key = _reservedProxiedKeys[_i];
    proxyFieldToLogic(wrapper, key);
  }
  for (var _i2 = 0, _Object$keys = Object.keys(getContext().plugins.logicFields); _i2 < _Object$keys.length; _i2++) {
    var _key = _Object$keys[_i2];
    proxyFieldToLogic(wrapper, _key);
  }
}
function unmountedActionError(key, path) {
  return "[KEA] Can not access \"" + key + "\" on logic \"" + path + "\" because it is not mounted!\nThis can happen in several situations:\n- You may need to add the \"connect(otherLogic)\" logic builder, or \"useMountedLogic(otherLogic)\" hook to make sure the logic is mounted.\n- If \"otherLogic\" is undefined, your bundler may import and execute code in an unfavourable order. Switch to a function: \"connect(() => otherLogic)\" \n- It may be that the logic has already unmounted. Do you have a listener that is missing a breakpoint?";
}

function getOrCreateContextForLogicWrapper(logic) {
  var context = getContext().react.contexts.get(logic);
  if (!context) {
    context = /*#__PURE__*/React$1.createContext(undefined);
    getContext().react.contexts.set(logic, context);
  }
  return context;
}
function BindLogic(_ref) {
  var logic = _ref.logic,
    props = _ref.props,
    children = _ref.children;
  var LogicContext = getOrCreateContextForLogicWrapper(logic);
  var builtLogic = logic(props);
  useMountedLogic(builtLogic);
  return /*#__PURE__*/React$1.createElement(LogicContext.Provider, {
    value: builtLogic
  }, children);
}

var warned = process.env.NODE_ENV === 'test';
function Provider(_ref) {
  var children = _ref.children;
  if (!warned) {
    console.warn("[KEA] <Provider> is now a no-op and should be removed. If you need it for Redux, use react-redux's <Provider store={getContext().store} />, or use Kea's useSelector.");
    warned = true;
  }
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, children);
}

var ATTACH_REDUCER = ATTACH_REDUCER$1;
var DETACH_REDUCER = DETACH_REDUCER$1;
resetContext({}, true);

export { ATTACH_REDUCER, BindLogic, DETACH_REDUCER, Provider, actions, activatePlugin, addConnection, afterMount, batchChanges, beforeUnmount, closeContext, connect, corePlugin, createActionCreator, createStore, defaults, events, getContext, getPluginContext, isBreakpoint, isBuiltLogic, isLogicWrapper, kea, keaReducer, key, listeners, openContext, path, props, propsChanged, reducers, resetContext, selectors, setPluginContext, shallowCompare, sharedListeners, useActions, useAllValues, useAsyncActions, useMountedLogic, useSelector, useValues };
